/**
 * @mainpage librdesc
 *
 * @section Introduction
 *
 * librdesc is a table-driven recursive descent parsing library written in C99.
 *
 * - Table-Driven Parsing: Parser logic is generic and can be controlled at
 *   runtime without recompiling.
 * - Pump Mechanism: Parsing is driven by `rdesc_pump()`, a state machine that
 *   allows token by token feeding.
 * - Robus Error Recovery: The engine handles memory allocation errors and
 *   remains in a valid state even if memory allocation fails.
 * - Ordered-choice Semantics: Parses grammars using prioritized alternatives
 *   where the first matching variant is selected. Provides unlimited lookahead
 *   via backtracking.
 *
 * @section API Overview
 *
 * 1. Parser (`rdesc.h`): The engine that consumes tokens. It defines the core
 *    algorithm - the parser state machine.
 * 2. Tree macros (`cst_macros.h`): Macros to access fields of CST.
 * 3. Grammar (`grammar.h`): Defines the grammar struct for construction
 *    rules, which usually populated with static constant data using macros.
 * 4. Rule macros (`bnf_macros.h`): A set of macros to facilitate definning
 *    rdesc grammars. See @ref examples_sec for usage.
 * 5. Optional features (`util.h`): Development and debugging utilities.
 *
 *
 * @section quickstart_sec Quick Start Guide
 *
 * To use librdesc, you typically follow these steps:
 *
 * 1. Define the identifiers of tokens and nonterminals (e.g. create enums for
 *    your language symbols)
 * 2. Define your grammar and its symbol table. You may use `bnf_macros.h` to
 *    create the rules table.
 * 3. Initialize:
 * @code{.c}
 * struct rdesc_grammar grammar;
 * rdesc_grammar_init(&grammar, ...);  // Load your rules
 *
 * struct rdesc parser;
 *                              // vvv function pointer for freeing seminfo
 * rdesc_init(&parser, &grammar, 8, token_destroyer_method);
 *                           // ^^^ 8 is the size your grammar's semantic
 *                           // information
 * @endcode
 * 4. Pump Tokens: Feed tokens into the loop until a tree is ready.
 * @code{.c}
 * rdesc_start(&parser, NT_STMT);  // Set your start symbol.
 *
 * enum rdesc_result parser_state;
 * do {
 *     // Acquire next_token from your lexer.
 *     uint16_t tk = next_tk();
 *     void *seminfo = next_seminfo();
 *
 *     parser_state = rdesc_pump(&parser, tk, seminfo);
 * } while (parser_state == RDESC_CONTINUE);
 *
 * if (res == RDESC_READY) {
 *      struct rdesc_node *cst = rdesc_root(&parser);
 *      // Process the `cst` (use `cst_macros.h`)
 * } else if (res == RDESC_NOMATCH) {
 *      // Handle syntax errors.
 * }
 * @endcode
 *
 *
 * @section examples_sec Examples
 *
 * - @ref boolean_algebra.h : A Boolean Algebra grammar demonstrating
 *   backtracking and ambiguity handling.
 * - @ref bc.h : A Basic Calculator implementation demonstrating operator
 *   precedence and expressions.
 *
 *
 * @section build_sec Building
 *
 * See @ref README.md for building instructions.
 */
